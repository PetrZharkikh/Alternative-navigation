# -*- coding: utf-8 -*-
"""
Начало работы 7.04.2023

Автор: Петросян

Модуль используется для работы с одиночными аэрофотоснимками.

Выполняются следующие задачи:
|begin{itemize}
|item чтение изображения из файла с извлечением exif-данных и данных телеметрии
      из сопровождающих файлов, если они есть.
      Извлекаются данные о GPS положении камеры, фокусном расстоянии и т.д.;
|item выполнение геометрической коррекции изображения на основе данных
      телеметрии: исправление дисторсии, перспективных искажений; ориентация
      по сторонам света;
|item привязка к геодезическим системам координат на основе данных телеметрии.
|item сохранение расчитанных данных в файле конфигурации изображения
|sstr{oneImagetmImagesaveIni}.
|end{itemize}

Данные файлов конфигурации используются при обработке групп изображений
аэрофотоландшафта. Если данных телеметрии нет, то они могут быть получены и
сохранены при обработке групп изображений на основе их взаимного положения и
GPS-координат камеры во время съёмки.

Для работы с изображением используется класс |texttt{tmImage}
|sstr{oneImagetmImage}.

В текстах комментариев часто упоминается выражение <<используется как
служебная функция, класс, метод, переменная>>. Это означает, что данные
программные компоненты обслуживают другие компоненты, упрощают их работу, или
делают программный код более лаконичным, но сами по себе не представляют
интереса.
"""

import configparser as cp #Импорт модуля для работы с ini-файлом
import time #Модуль для работы с датой и временем
from skimage import transform, io, util
#import cv2 #Модуль для работы с OpenCV
import os.path as osp #Модуль для работы с именами файлов
import numpy as np #Модуль для работы с массивами
from exif import Image#Импортируем Image из exif для чтения метаданных
import trMatrix #Модуль с вспомогательными функциями для трансформации
import os

notDoc=['Image'] #Указываются имена атрибутов модуля, которые не нужно включать в документацию

class exGeomKorr(Exception):
    '''
Класс исключительной ситуации.

Вызывается для генерации исключительной ситуации, когда продолжение вычислений
невозможно. По возникновению экземпляра этого класса принимается решение об
остановке вычислений или использования альтернативных вариантов.
    '''
    pass

def readExif(fn):
    '''
Читает exif данные из файла |texttt{fn}.

Входные данные:

|noindent|texttt{fn} -- имя файла с изображением.

Применяется для чтения данных, которые находятся вместе с изображением.
Как правило, там есть данные о названии камеры, производителе, времени съёмки,
фокусное расстояние объектива, выдержка, GPS-координаты, иногда данные
телеметрии.

Результат: Возвращает объект, в котором через его переменные можно извлечь
значения exif-данных.

Для того чтобы извлечь значение высоты съёмки нужно: получить объект с
данными с помощью этой функции и извлечь данные о высоте как показано
в примере:
|begin{lstlisting}[language=python]
>>>a=readExif('1.jpg') #Получаем объект с exif-данными в файле 1.jpg
>>>b=a.gps_altitude #Извлекаем данные о высоте съёмки
|end{lstlisting}

Узнать какие есть поля можно с помощью метода |texttt{list|_all()}, который
вернёт спиков всех переменных.
    '''
    with open(fn, 'rb') as f:
        exifDan=Image(f)
    if not(exifDan.has_exif):
        raise exGeomKorr('Файл: "'+fn+'" не содержит exif-данных')
    return exifDan

def exifNameCamera(exifDan):
    '''
Возвращает название камеры: изготовитель+модель через пробел. Полученное
название используется при чтении пользовательских данных функцией
|texttt{imPars} |sstr{oneImageimPars}.

Входные данные:
    
|texttt{exifDan} -- данные exif-файла (результат функции: readExif)
|sstr{oneImagereadExif}.

Результат: строка с названием камеры и производителем.
    '''
    return exifDan.make+' '+exifDan.model

def exifGPS(exifDan):
    '''
Извлекает GPS-координаты из exif-данных.

Входные данные:

|texttt{exifDan} -- exif-данные, полученные функцией |texttt{readExif}
|sstr{oneImagereadExif}.

Результат: GPS-координаты камеры в виде словаря:

|begin{itemize}
|item |texttt{altitude} -- высота относительно уровня моря;
|item |texttt{latitude} -- широта места;
|item |texttt{longitude} -- долгота места;
|end{itemize}
    '''
    try:
        lat=exifDan.gps_latitude
        lon=exifDan.gps_longitude
        d={'altitude':exifDan.gps_altitude}
        lat1=lat[0]+lat[1]/60+lat[2]/3600
        lon1=lon[0]+lon[1]/60+lon[2]/3600
        lat1=lat1 if exifDan.gps_latitude_ref=='N' else -lat1
        lon1=lon1 if exifDan.gps_longitude_ref=='E' else -lon1
        d['latitude']=lat1
        d['longitude']=lon1
        return d
    except:
        raise exGeomKorr('Нет GPS-данных')

def imPars(nameCamera):
    '''
Получение пользовательских данных камеры с изображением.

Входные данные:

|noindent|texttt{nameCamera} -- название камеры. Результат функции
|texttt{exifNameCamera} |sstr{oneImageexifNameCamera}.

В этот файл можно самостоятельно записывать данные камеры, которые не
отображаются в exif-данных, но которые есть в документации или других
источниках. К ним могут относиться углы обзора по ширине и высоте кадра.

Файл содержит секции в квадратных скобках и значения параметров.
Название секции содержит изготовителя и модель камеры, которые берутся
из exif-данных файла: изготовитель+модель через пробел (результат
функции |texttt{exifNameCamera}).

В файле могут быть указаны:

|noindent|texttt{widthpixmax=ширина изображения в пикселях}

|noindent|texttt{heightpixmax=высота изображения в пикселях}

|noindent|texttt{fovwidth=угол обзора объектива по ширине изображения}

|noindent|texttt{fovheight=угол обзора объектива по высоте изображения}

|noindent|texttt{focus=фокусное расстояние}
    '''
    iniParam=cp.ConfigParser()
    iniParam.read('cameras.ini')
    camPar={'camera':nameCamera} #Словарь параметров
    if iniParam.has_section(nameCamera):
        camPar['widthangle']=iniParam.getfloat(nameCamera,'fovwidth', fallback='None') #угол обзора объектива по ширине изображения
        camPar['heightangle']=iniParam.getfloat(nameCamera,'fovheight', fallback='None') #угол обзора объектива по высоте изображения
        camPar['focus']=iniParam.getfloat(nameCamera,'focus', fallback='None') #фокусное расстояние
        camPar['width']=iniParam.getint(nameCamera,'widthpixmax', fallback='None') #ширина изображения в пикселях
        camPar['height']=iniParam.getint(nameCamera,'heightpixmax', fallback='None') #высота изображения в пикселях
        camPar['distors']=iniParam.getfloat(nameCamera,'distors', fallback='None') #Радиус дисторсии
        camPar['typedist']=iniParam.get(nameCamera,'typedist', fallback='None') #Тип дисторсии
    return camPar

#print(imPars('DJI XT2')) #Отладка
    
class tmcsv:
    '''
Класс для чтения файла телеметрии |texttt{tm.csv} и поиска нужной записи.
Используется как служебный класс классом |texttt{tmImage}
|sstr{oneImagetmImage}.

Файл телеметрии может находиться в папке с изображениями созданными БпЛА
<<Орлан-10>>. В этом файле записаны данные о положении и ориентации в пространстве
БпЛА. Каждому файлу с изображением в папке соответсвует запись (строка) в
файле телеметрии. Задача данного класса заключается в нахождении соответсвующей
записи по имени файла с изображением.

Данный класс используется классом |texttt{tmImage} |sstr{oneImagetmImage} и
снабжает его данными телеметрии, когда |texttt{tmImage} открывает какое-либо
изображение.

Файл телеметрии представляет таблицу данных и содержит колонки:
|begin{itemize}
|item |texttt{Timestamp} -- строка с датой и времени съёмки в формате
      '|%Y-|%m-|%d |%H:|%M:|%S.SSSSS';
|item |texttt{CamAngleRange} --
|item |texttt{CamAzimuthRange} --
|item |texttt{CameraAngle} --
|item |texttt{CameraAzimuth} --
|item |texttt{FocalLength} --
|item |texttt{gpsAlt} --
|item |texttt{nYaw} --
|item |texttt{Pitch angle} -- тангаж;
|item |texttt{Roll angle} -- крен;
|item |texttt{Yaw angle} -- скольжение (рыскание);
|item |texttt{Altitude} -- высота относительно уровня моря;
|item |texttt{Latitude} -- широта места;
|item |texttt{Longitude} -- долгота места;
|item |texttt{Speed} -- скорость полёта.
|end{itemize}'''
    def __init__(self,fn):
        '''
Конструктор класса |texttt{tmcsv}.

Входные данные:

|texttt{fn} -- имя файла с телеметрией. Как правило он находится
в папке и изображениями и имеет имя |texttt{tm.csv}.

Открывает файл |texttt{fn} и создаёт словарь |texttt{tmStr}, где ключ --
имя файла с изображением без расширения; значение -- список параметров в
последовательности, указанной в списке |texttt{shapka}.
        '''
        try:
            f=open(fn,'rt')
        except:
            raise exGeomKorr('Отсутствует файл телеметрии: '+fn)
        else:
            self.shapka=f.readline()
            self.shapka=f.readline().lower().split(',')
            self.shapka[0]='timestamp'
            self.shapka[-1]=self.shapka[-1][:-1]
            self.tmStr={}
            for s in f:
                ss=s.split(',')
                ss[-1]=ss[-1][:-1]
                fileIm=ss[0].split(':')[-1]
                for i in range(1,len(ss)):
                    ss[i]=float(ss[i])
                self.tmStr[fileIm]=ss
        finally:
            f.close()
        
    def params(self,key):
        '''
Возвращает словарь с параметрами для ключа |texttt{key}.

Входные данные:
    
|texttt{key} -- имя файла с изображением без расширения.

Результат: словарь параметров телемтрии, которые указаны в описании класса
|sstr{oneImagetmcsv}.
        '''
        return dict(zip(self.shapka,self.tmStr[key]))
#======================================================
        
def strTime2struct_time(strTime):
    '''
Преобразует строку с датой и временем в поле |texttt{Timestamp} в
формат |texttt{time.struct|_time}. Теряются доли секунд.
Используется как служебная функция.
    '''
    if not(isinstance(strTime,str)):
        st=strTime['Timestamp']
    else:
        st=strTime
    s=st.split('.')[0]
    return time.strptime(s,'%Y-%m-%d %H:%M:%S')

class tmImage:
    '''
Класс для работы с одиночными изображениями аэрофотоландшафта.

При работе с изображениями аэрофотоландшафта возникают задачи, связанные с
привязкой изображений к географическим системам координат, сшивки серии
изображений между собой, коррекции перспективных искажений и так далее,
вплоть до описания содержимого и условий съёмки.

Класс может работать с разномасштабгыми изображениями, но всегда только с
одним. Для изменения масштаба нужно указать коэффициент увеличения при создании
экземпляра класса |sstr{oneImageinit}. Если изображения с различными масштабами
уже создавались ранее, то для работы с ними нужно открывать исходное
изображение с указанием нужного масштаба.

Данный класс предназначен для накопления информации об изображении и применении
этой информации в нужное время. Так как обработка изображений, а особенно
серии изображений, ресурсоёмкий процесс, то основний принцип, который
соблюдается при использовании этого класса -- параметры по изображениям не
должны вычисляться дважды, а тем более многократно. Если какой-либо параметр
вычислен, то он сохраняется в файле конфигурации этого изображения и в
следующих сеансах работы берётся из этого файла. Таким образом, достигается
экономия вычислительных ресурсов сисистемы обработки изображений в целом.

Сохранённые в файле конфигурации параметры изображения читаются при загрузке
изображения конструктором класса |texttt{|_|_init|_|_}. Если изображение
читается впервые, то о нём собираются все доступные сведения
|sstr{oneImagetmImageinit}.

В процессе работы экземпляра этого класса собранные об изображении сведения
сохраняются в словаре |texttt{par} и сохраняются в файле конфигурации
изображения деструктором |texttt{|_|_del|_|_} |sstr{oneImagetmImagedel}.

Словарь |texttt{par} может пополняться любыми данными. Туда могут заносить
данные другие программные единицы, которые используют этот класс как
подчинённый и находить там сохранённые ими данные.

Для создания экземпляра класса необходимо указать файл с изображением для
работы. Например,

|begin{lstlisting}[language=python]
#Создание экземпляра класса a с изображением из файла 1.jpg
>>>a=tmImage('1.jpg')
|end{lstlisting}

К прочитанному изображению можно обратиться через свойство экземпляра класса
|texttt{im} |sstr{oneImagetmImageim}.

|begin{lstlisting}[language=python]
>>>a.im
|end{lstlisting}

Если есть данные телеметрии БпЛА такие как: крен, тангаж, азимут, то можно
получить скорректированное изображение через свойство |texttt{imCorrect}
|sstr{oneImagetmImageimCorrect}.

|begin{lstlisting}[language=python]
>>>a.imCorrect
|end{lstlisting}

Скорректированное изображение имеет одинаковый масштаб по всей плоскости и
ориентировано по сторонам света. Также будет устранена дисторсия, если
есть данные о ней в файле |texttt{cameras.ini} |sstr{oneImageimPars}. Если данных для
коррекции изображения нет, то это свойство вернёт исходное изображение.

Изображения в свойствах |texttt{im} и |texttt{imCorrect} хранятся в оперативной
памяти и чтобы их увидеть на экране нужно воспользоваться командой для
вывода изображения на экран из какого-либо пакета Python по обработке
изображений, например, |texttt{skimage}.

|begin{lstlisting}[language=python]
>>>io.imshow(a.imCorrect) #Вывести изображение на экран
|end{lstlisting}

Данная команда будет работать если вы уже выполняли этот модуль, так как
при его выполнении в интерпретатором будет загружен модуль |texttt{io} командой
|texttt{import skimage.io as io}, которая находится в начале этого модуля.

Однако, если изображение подвергалось переносу, то перенос может вывести
изображение из его начальной области координат, то есть из области видимости.
В этом случае можно увидеть часть изображения или вообще чёрный холст.

Для того чтобы гарантированно увидеть изменённое изображение можно
воспользоваться функцией |texttt{calcShape} из модуля |texttt{trMatrix}
|sstr{trMatrixcalcShape}. Данная функция вычислит необходимый размер холста и
матрицу переноса трансформированного изображения на этот холст. Тогда увидеть
изображение можно с применением команд:

|begin{lstlisting}[language=python]
#Вычисляем размер нового холста newShape и матрицу переноса на этот холст reM
newShape, newLeftUp, reM=trMatrix.calcShape(a.imCorrect.shape, a.m_all)
#Вычисляем общую матрицу трансформации
>>>m=np.matmul(a.m_all, reM)
#Вычисляем трансформированное изображение в области видимости нового холста
>>>b=transform.warp(a.imCorrect, np.linalg.inv(m), output_shape=newShape, preserve_range=True)
#Приводим изображение к формату для вывода
>>>b=np.array(b, dtype=np.uint8)
#Выводим изображение на экран
>>>io.imshow(b)
|end{lstlisting}

В данном классе нет специальной функции для вывода скорректированного
изображения на экран так как не предполагается, что он будет использован
для этих целей.

Экземпляры класса могут вычислять матрицы трансформации через свойства:

|begin{itemize}
|item |texttt{m|_projective} -- устранение перспективных искажений
          |sstr{oneImagetmImagemprojective};
|item |texttt{m|_north} -- ориентация изображения по сторонам света
          |sstr{oneImagetmImagemnorth};
|item |texttt{m|_all} -- все трансформации |sstr{oneImagetmImagemall};
|end{itemize}
    '''
    
    @property
    def im(self):
        '''
Свойство с исходным изображением. К нему можно обращаться как к переменной,
но фактически он является методом, который вернёт исходное изображение.
Если изображение уже прочитано из файла, то оно будет доступно. Если не
прочитано, то оно будет загружено из файла. Таким образом, нет необходимости
следить за тем прочитано изображение или нет. Нужно просто к нему обратиться.

Прочитанное изображение хранится в служебной переменной |texttt{|_im}.
Если изображение ещё не прочитано, то |texttt{|_im=None}

Во многих случаях машинной обработки данных, когда визуально изображение
оценивать нет необходимости, многие параметры можно вычислить по матрицам
трансформации, например, географические координаты БпЛА во время съёмки, если
изображение ранее сшивалось с предыдущим.
        '''
        if self._im is None:
            try:
                #self._im=cv2.imread(self.filename, cv2.IMREAD_COLOR)#/255
                self._im=io.imread(self.filename)
                self.par['height']=self._im.shape[0]
                self.par['width']=self._im.shape[1]
            except:
                raise exGeomKorr('Файл с изображением не найден или не может быть прочитан.')
        return self._im
    
    @property
    def imCorrect(self):
        '''
Свойство с изображением, в котором исправлены: дисторсия, крен, тангаж,
ориентация по сторонам света. Если исходное изображение не подвергалось
коррекции, то коррекция будет произведена в соответствии с доступными
данными. Если данных, по дисторсии камеры, крену, тангажу, азимуту нет,
то будет представлено исходное изображение, Если коррекция проводилаь ранее
и скорректированное изображение было сохранено в файле, то будет прочитано
изображение из файла.

Понять какие деформации исходного изображения применялись, а какие нет можно
проанализировав значения в словаре |texttt{self.par}:

|begin{itemize}
|item |texttt{flagdistors} -- если |texttt{True}, то применялась коррекция
      дисторсии;
|item |texttt{flagprojective} -- если |texttt{True}, то исправлялись
      проективные искажения, связанные с креном и тангажом воздушного судна.
      В этом случае в словаре присутствуют ключи |texttt{pitch angle} и
      |texttt{roll angle} и хотя бы один из них не равен нулю;
|item |texttt{flagnorth} -- если |texttt{True}, то изображение ориентировано
      по сторонам света. Верхний обрез изображения ориентирован на север,
      при этом видно, что изображение повёрнуто внутри холста, который имеет
      пустые чёрные области.
|end{itemize}

Те же данные можно получить проанализировав файл конфигурации изображения
|texttt{*.ini} с тем же именем, что и файл с изображением. В нём можно найти
те же параметры и значения.
        '''
        if self._imCorrect is None:
            fnc=self.par['filenamecorrect']
            if fnc is None:
                #Если общая матрица преобразования единичная и параметров дисторсии нет,
                d=False
                if 'distors' in self.par:
                    if self.par['distors']!=None:
                        d=True
                if np.sum(np.eye(3)-self.m_all)==0 and not(d):
                    self._imCorrect=self.im #то скорректированное изображение такое же как исходное,
                else: #иначе нужно вычислить скорректированное изображение
                    self._imCorrect=self.warpImCorrect()
            else:
                self._imCorrect=io.imread(osp.join(self.dirName, fnc))
        return self._imCorrect
    
    @property
    def m_all(self):
        '''
Свойство с матрицей получения скорректированного изображения, учитывающего.
перспективные искажения и ориентацию по сторонам света. То есть, для
получения изображения в свойстве |texttt{imCorrect}.

Если матрица пересчёта отсутствует, то она будет вычислена. Если считалась
ранее и сохранялась в файле конфигурации изображения, то она читается из этого
файла при создании экземпляра класса |texttt{tmImage}.

Для вычисления этой матрицы перемножаются матрицы перспективных искажений в
свойствах |texttt{m|_projective} и |texttt{m|_north}.
        '''
        if self._m_all is None:
            self._m_all=np.matmul(self.m_north, self.m_projective) #Вычисление общей матрицы трансформации.
        return self._m_all
    
    @property
    def m_projective(self): #Матрица для исправления перспективных искажений
        '''
Свойство с матрицей для исправления перспективных искажений по крену и
тангажу.

Если матрица отсутствует, то она будет рассчитана или прочитана из файла
конфигурации изображения. При отсутствии данных по крену и тангажу будет
принята единичная матрица (главная диагональ имеет значения единицы, остальные
элементы -- нули). Такая матрица не приводит к геометрическим изменениям
изображения.
        '''
        if self._m_projective is None:
            #self._m_projective=self.m_projectiveCorrect()
            try:
                self._m_projective=trMatrix.m_ProjectiveCorrect(self.par['altitude'],
                    self.par['roll angle'], self.par['pitch angle'], 6000, #!!! Похоже вместо фокусного расстояния может быть число сколько раз фокусное расстояние укладывается в высоту съёмки.
                    self.par['width'], self.par['height'])
                self.par['flagprojective']=True
            except:
                self._m_projective=np.eye(3)
        return self._m_projective
    
    @property
    def m_north(self):
        '''
Свойство с матрицей для ориентации изображения по сторонам света.

Если матрица отсутствует, то она будет рассчитана или прочитана из файла
конфигурации изображения. При отсутствии данных по азимуту будет принята
единичная матрица.
        '''
        if self._m_north is None:
            #self._m_north=self.m_northCorrect()
            rRow=self.im.shape[0]/2
            rCol=self.im.shape[1]/2
            r=np.matmul(self.m_projective,np.array([[rCol],[rRow],[1]]))
            rRow=r[1][0]
            rCol=r[0][0]
            try:
                self._m_north=trMatrix.m_RotCenter(self.par['yaw angle'],(rRow,rCol))
                self.par['flagnorth']=True
            except:
                self._m_north=np.eye(3)
        return self._m_north
    
    def __init__(self, fim):
        '''
Конструктор класса |texttt{tmImage}. Создаёт экземпляр класса и инициализирует
его параметры. Для создания экземпляра класса необходимо передать имя файла с
изображением конструктору. Конструктор собирает данные об открываемом
изображении, но не читает само изображение, так как заранее неизвестно нужно ли
работать с ним или только с его параметрами. К изображению можно обратиться
через свойство |texttt{im}. Данное свойство читает изображение из файла при
первом обращении.

Входные параметры:

|begin{itemize}
|item |texttt{fim} -- имя файла с изображением;
|item |texttt{zoom} -- коэффициент увеличения исходного изображения (по
      умолчанию 1).
|end{itemize}

Параметры изображения хранятся в файле конфигурации |texttt{*.ini}, его
название (|texttt{*}) совпадает с именем файла изображения. Этот файл создаётся
при первом чтении изображения. В нём хранятся все полученные и расчитанные
данные.

Если такой файл присутствует, то все данные берутся оттуда и повторно не
вычисляются. Это экономит время обработки изображений в нескольких сессиях.

Если такого файла нет, то собирается доступная информация об изображении в
следующем порядке:

|begin{enumerate}
|item файл |texttt{cameras.ini} -- пользовательский файл для недостающих
      данных, которые могут быть получены из других источников;
|item exif-данные файла с изображением;
|item данные телеметрии в файле tm.csv в папке с файлом изображения.
|end{enumerate}

Приоритет данных повышается в порядке очерёдности чтения. Любой из файлов может
отсутствовать, либо отсутствовать exif-данные.
        '''
        self.filename=fim #Имя файла с исходным изображением
        self.dirName=osp.dirname(fim) #Рабочая папка
        self._im=None #Служебная переменная для хранения исходного изображения
        self._imCorrect=None #Служебная переменная для хранения скорректированного изображения
        self.par={} #Все доступные данные из exif, телеметрии и пользовательские
        self._m_projective=None #Служебная переменная для хранения матрицы проективных искажений
        self._m_north=None #Служебная переменная для хранения матрицы поворота на север
        self._m_canvas=None #Служебная переменная для хранения матрицы размещения скорректированного изображения на индивидуальный холст
        self._m_all=None #Служебная переменная хранящая татрицу всех трансформаций.
        self.m_canvas=None #Матрица переноса скорректированного изображения на индивидуальный холст. Вычисляется в методе warpImCorrect.
        self.m_previous=None #Матрица для сшивки изображения с предыдущим в последовательности. Рассчитывается в serialImage.py
        self.m_geo=None #Матрица географической привязки
        self.par['filenamecorrect']=None #Имя файла с трансформированным изображением
        self.par['postfixfilename']='_correct' #Постфикс в именах файлов скорректированных изображений
        self.par['flagdistors']=False #Если True, то выполнена коррекция дисторсии
        self.par['filename']=osp.basename(fim) #Базовое имя файла с исходным изображением
        self.par['flagprojective']=False #Произведена ли коррекция перспективы
        self.par['flagnorth']=False #Произведён ли поворот на север.
        if not(self.loadIni()): #Читаем данные параметров изображения. Если они прочитаны, то exif и телеметрия читались ранее.
            try: #Читаем exif-данные
                exifDan=readExif(fim) #Читаем exif-данные
                nameCamera=exifNameCamera(exifDan) #Получаем название камеры
                self.par.update(imPars(nameCamera)) #Читаем пользовательские данные камеры
                self.par.update(exifGPS(exifDan)) #Добавляем в словарь GPS-данные
            except: pass
            try: #Читаем данные из файла телеметрии tm.csv
                self.fntm=osp.dirname(fim)+'/tm.csv' #Файл с телеметрией
                tm=tmcsv(self.fntm) #Читаем телеметрию
                key=osp.splitext(osp.split(fim)[1])[0] #Извлекаем имя файла без пути и расширения
                self.par.update(tm.params(key)) #Получаем данные телеметрии для файла с изображением
            except: pass
        if not('width' in self.par):
            self.im
        
    def __del__(self):
        '''
Деструктор класса. Вызывается когда экземпляр класса уничтожается сборщиком
мусора. В этот момент деструктор сохраняет все полученные данные об изображении
в файле конфигурации изображения для работы в следующих сессиях.

Сборщик мусора -- встроенный алгоритм интерпретатора Python, который уничтожает
неиспользуемые данные. Неиспользуемыми данными считаются данные, на которые
не ссылается ни одна переменная программы. К таким данным программа уже не
может получить доступ.

Неизвестно когда сборщик мусора уничтожит ненужные данные, но точно известно,
что он выполнит свою работу при завершении программы.
        '''
        self.saveIni()
    
    def distorsCorrect(self):
        '''
Коррекция бочкообразной или подушкообразной дисторсии.

Метод выполняется если есть данные о дисторсии камеры и вызвано свойство
|texttt{imCorrect} |sstr{oneImagetmImageimCorrect}.
        '''
        if not('distors' in self.par):
            raise exGeomKorr('Нет данных для коррекции дисторсии.')
        if self.par['distors'] is None:
            raise exGeomKorr('Нет данных для коррекции дисторсии.')
        barrel=True if self.par['typedist']=='barrel' else False
        self._imCorrect=trMatrix.distorsBP(self.im, self.par['distors'], barrel)
        self.par['flagdistors']=True
        self.saveImCorrect()

    def warpImCorrect(self):
        '''
Создаёт скорректированное изображение, используя матрицу со всеми
трансформациями |texttt{m|_all} |sstr{oneImagetmImagemall}.
        '''
        try:
            self.distorsCorrect()
            im=self._imCorrect
        except:
            im=self.im
        #Вычисляем новый размер холста, на который поместится трансформированное изображение и матрицу переноса на этот холст.
        newShape, lu, reM=trMatrix.calcShape(im.shape, self.m_all)
        self.m_canvas=np.matmul(self.m_all, reM)
        imt=transform.warp(im, np.linalg.inv(self.m_canvas),
                           output_shape=newShape, preserve_range=True)
        self.par['heightcorrect']=imt.shape[0]
        self.par['widthcorrect']=imt.shape[1]
        return np.array(imt, dtype=np.uint8)
    
    def saveImCorrect(self):
        '''
Сохраняет трансформированное изображение в файл.

Имя файла создаётся автоматически путём добавления постфикса к имени исходного
файла. Постфикс определён в параметре |texttt{self.par['postfixfilename']},
который по умолчанию имеет значение: |texttt{|_correct}.
        '''
        im=self.imCorrect
        fil, ext=osp.splitext(self.par['filename'])
        baseNameCorrect=fil+self.par['postfixfilename']+ext
        self.par['filenamecorrect']=baseNameCorrect
        fn=osp.join(self.dirName, baseNameCorrect)
        io.imsave(fn, im)
        self.par['widthcorrect']=self.imCorrect.shape[1]
        self.par['heightcorrect']=self.imCorrect.shape[0]
    
    def saveIni(self):
        '''
Сохраняет в |texttt{*.ini} файле все полученные в результате обработки данные.
Эти данные будут использоваться в следующих сеансах работы или другими
компонентами, чтобы не производить расчёты повторно.

Файл конфигурации изображения представляет собой текстовый файл, который по
имени совпадает с файлом изображения, но имеет расширение |texttt{ini}.

В этом файле есть секции, названия которых заключены в квадратные скобки и
парметры внутри секций. Каждая секция и параметр занимают одну строку.
Каждый параметр имеет имя и значение. Данные файлы можно просматривать и
редактировать в текстовом редакторе. Они удобны для хранения небольших объёмов
информации, которую можно представить в текстовом виде.
        '''
        baseName=osp.basename(self.filename) #Базовое имя файла
        fil, ext=osp.splitext(baseName)
        dirName=osp.dirname(self.filename) #Путь к файлу
        baseNameIni=fil+'.ini'
        fileNameParam=osp.join(dirName, baseNameIni)
        iniF=cp.ConfigParser() #Объект для работы с ini-файлом
        iniF.add_section('matrix')
        for i in self.__dict__:
            if i[:2]=='m_':
                m=self.__dict__[i]
                if isinstance(m, np.ndarray):
                    iniF.set('matrix', i, np.array2string(m,separator=',').replace('\n', ''))
        iniF.add_section('params')
        for i in self.par: #Сохраняем параметры полученные при первой загрузке изображения
            iniF.set('params', i, str(self.par[i]))
        with open(fileNameParam, "w") as config_file:
            iniF.write(config_file)
    
    def loadIni(self):
        '''
Метод ддля загрузки данных из |texttt{*.ini} файлов конфигурации изображений.
Так как эти файлы содержат наиболее полную и актуальную информацию по
изображениям, то приоритет отдаётся информации именно из них, если они есть.
Эти файлы отсутствуют при первом открытии файлов с изображениями. При обработке
изображений и вычислении необходимых параметров всё заносится в |texttt{*.ini}
файлы конфигурации изображений и в дальнейшем не пересчитывается для экономии
времени.

Файл конфигурации изображения |texttt{*.ini} находится вместе с файлом
изображения.
        '''
        baseName=osp.basename(self.filename)
        dirName=osp.dirname(self.filename)
        fil, ext=osp.splitext(baseName)
        fn=osp.join(dirName, fil+'.ini')
        if not(osp.exists(fn)):
            return False
        iniParam=cp.ConfigParser()
        iniParam.read(fn)
        listM=iniParam.options('matrix')
        for i in listM:
            sm=iniParam.get('matrix', i)
            m=eval('np.array('+sm+')')
            try:
                setattr(self, i, m)
            except:
                setattr(self, '_'+i, m)
        listSP=iniParam.options('params')
        for i in listSP:
            s=iniParam.get('params', i)
            if s=='True':
                r=True
            elif s=='False':
                r=False
            elif s=='None':
                r=None
            else:
                try: #Проверяем в какой тип можно преобразовать строку
                    r=float(s)
                except:
                    try:
                        r=int(s)
                    except:
                        r=s
            self.par[i]=r
        return True
    
    def imClear(self):
        '''
Метод очищает свойства с изображениями.

При управлении серией изображений нерационально держать их все в оперативной
памяти. Это сильно сокращает вычислительные ресурсы. В этом случае есть
смысл выгрузить изображения из оперативной памяти, которые будут загружены
снова из файлов при первом обращении к ним. Параметры изображений остаются
доступны.

Напрямую, то есть как |texttt{self.im=None}, очистить нельзя, так как
свойства |texttt{im} и |texttt{imCorrect} доступны только для чтения.
        '''
        self._im=None
        self._imCorrect=None
    
    def getM(self, mName):
        '''
Возвращает матрицу трансформации по имени из атрибутов экземпляра класса,
если она есть. В противном случае возвращает |texttt{None}.
        '''
        if mName in self.__dict__:
            return self.__dict__[mName]
        else:
            return None
    
    def xy2geo(self,xy):
        '''
Вычисляет географические координаты по пиксельным координатам, если существует
матрица географической привязки |texttt{m|_geo}, в противном случае --
возвращает |texttt{None}.

Входные данные:

|begin{itemize}
|item |texttt{xy} -- кортеж пиксельных координат |texttt{(x, y)}
|end{itemize}

Результат: |texttt{(lambda, phi)} -- кортеж действительных чисел с долготой и
           широтой указанного пиксела.
        '''
        m_Geo=self.getM('m_geo')
        if m_Geo is None:
            return None
        else:
            xy1=np.array([[xy[0]],
                      [xy[1]],
                      [1]])
            pl=np.matmul(m_Geo,xy1)
            pl=pl/pl[2,0] #Деление на масштабный коэффициент
            return (pl[0,0], pl[1,0])

class resizeTmImage(tmImage):
    '''
Класс для работы с уменьшенной копией изображения.

Данный класс является дочерним по отношению к |texttt{tmImage} и наследует
все его атрибуты. Перегружен конструктор класса |sstr{oneImagetmImageinit}.
    '''
    
    def __init__(self, filename, n=0.25, dirMiniImages=None):
        '''
Конструктор класса перегружен. Он вызывает конструктор
родительского класса, уменьшает исходное изображение, сохраняет его в другую
папку и работает с ним, используя методы родительского класса. За счёт этого
уменьшается время вычисления взаимного положения изображений.

Изменение размера изображения производится только при отсутствии матрицы
привязки к предыдущему изображению. Если эта матрица присутствует в файле
конфигурации изображения, то данный класс будет работать так же как и
родительский. Связано это с тем, что уменьшение размера изображения необходимо
для сокращения времени привязки изображений между собой. Если матрица уже есть,
то такая необходимость отпадает.

Попытка открыть изображение с уменьшением размера и имеющейся матрицей привязки
приведёт к возникновению больших погрешнойстей при создании ортофотоплана и
вычислении координат. Поэтому данный класс будет выполнять уменьшение только
новых, не подвергавшихся ранее обработке, изображений.

Входные параметры:

|begin{itemize}
|item |texttt{filename} -- строка с именем открываемого файла с изображением;
|item |texttt{n} -- параметр изменения размера исходного изображения. Если это
      действительное число, то количество строк и колонок исходного изображения
      умножается на этот коэффициент. По умолчанию он равен 0.25, то есть
      изображение будет уменьшено в 4 раза по строкам и колонкам, или в 16 раз
      по площади. Можно дать кортеж с целыми числами, в котором указать
      количество строк и колонок изображения, например: |texttt{n=(640, 480)}.
      Предпочтительно указать действительный коэффициент, так как не нужно
      учитывать пропорции ширины и высоты исходного и требуемого изображения.
|item |texttt{dirMiniImages} -- строка с именем папки, в которую нужно
      записывать изменённые изображения. Если не она указана, то в той же папке
      будет создана папка с постфиксом |texttt{|_mini}. Например, исходные
      файлы с изображениями находятся в папке |texttt{a/b}, тогда изменённые
      файлы будут записаны в папку |texttt{a/b|_mini}.
|end{itemize}
        '''
        super().__init__(filename)
        if self.m_previous is None:
            im=io.imread(filename)
            if isinstance(n, float):
                n=(int(im.shape[0]*n), int(im.shape[1]*n))
            self._im=util.img_as_ubyte(transform.resize(im, n))
            self.par['height']=self._im.shape[0]
            self.par['width']=self._im.shape[1]
            if dirMiniImages is None:
                dirFiles=osp.dirname(filename) #Папка с исходными файлами
                dirUp=osp.dirname(dirFiles) #Внешняя папка
                dirMiniImages=osp.join(dirUp, osp.basename(dirFiles)+'_mini')
            self.filename=osp.join(dirMiniImages, osp.basename(filename))
            if not(osp.isdir(dirMiniImages)):
                os.mkdir(dirMiniImages)
            io.imsave(self.filename, self._im)
            self.saveIni()
            
        

#im=reziseTmImage('f\\DJI_0001.JPG')
#im=tmImage('13-47/23.14923.jpg')
#im.loadIni()
#im=tmImage('DJI_0001.jpg')
#print(im.m_projective)
#im.m_allCorrect()
#a=im.imCorrect
#io.imshow(a)
#im.saveIni()
#im.saveImCorrect()
#im=None
#im.saveIni()
